<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <style>
    body { margin:0;position:fixed;top:0;right:0;bottom:0;left:0; }

    .axis line {
      stroke: none;
    }

    .gridline line,
    .gridline path {
      stroke: grey;
      stroke-width: 0.7;
      stroke-dasharray: 5;
      opacity: 0.5;
    }
  </style>
</head>

<body>
  <script>

    d3.csv('_Revenue_.csv', function(wide_data){
      var long_data = []
      wide_data.forEach(function(row){
        Object.keys(row).forEach( function(colname) {
          // Ignore 'State' and 'Value' columns
          if(colname == "Head" || colname == "Type") {
            return
          }
          long_data.push({"Head": row["Head"], "Type": row["Type"], "Value": row[colname], "Year": colname});
        });

      })
      //console.log(long_data);

      var nest = d3.nest()
        .key(function(d) { return d["Year"] }) // sort by key
        .rollup(function(s) { // do this to each grouping
          // reduce takes a list and returns one value
          // in this case, the list is all the grouped elements
          // and the final value is an object with keys
          return s.reduce(function(prev, curr) {
            prev["Year"] = curr["Year"];
            prev[curr["Head"]] = +curr["Value"];
            return prev;
          }, {});
        })

      var wide = nest.entries(long_data) // tell it what data to process
                    .map(function(d) { // pull out only the values
                      return d.value;
                    });
      //})

      //console.log(wide);

      // draw the area chart now

      // defining the margins and the dimensions of chart
      var margin = {top: 20, right: 60, bottom: 30, left: 50},
      width = 600 - margin.left - margin.right,
      height = 350 - margin.top - margin.bottom;

      // time format for year
      var parseDate = d3.timeParse('%Y');

      // defining x and y scales
      var x = d3.scaleTime()
                .range([0, width]);

      var y = d3.scaleLinear()
        .range([height, 0]);
      // color scale for categories
      var color = d3.scaleOrdinal(d3.schemeCategory20);

      // defining the axes
      var xAxis = d3.axisBottom()
                    .scale(x);

      var xGridlines = d3.axisBottom()
                         .scale(x)
                         .tickSize(-height, 0, 0)
                         .tickFormat("")


      var yAxis = d3.axisRight()
                    .scale(y)

      var yAxisLeft = d3.axisLeft()
                    .scale(y)

      var area = d3.area()
                    .x(function(d) {
                      return x(d.data.Year);
                    })
                    .y0(function(d) { return y(d[0]); })
                    .y1(function(d) { return y(d[1]); });

      var stack = d3.stack()

      var svg = d3.select('body').append('svg')
                  .attr('width', width + margin.left + margin.right)
                  .attr('height', height + margin.top + margin.bottom)
                  .append('g')
                  .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      //console.log(d3.keys(wide[0]));

      color.domain(d3.keys(wide[0]).filter(function(key) { return key !== 'Year'; }));
      var keys = d3.keys(wide[0]).filter(function(key) { return key !== 'Year'; })
      // parsing time variable of all years
      wide.forEach(function(d) {
        d.Year = parseDate(d.Year);
      });

      var maxDateVal = d3.max(wide, function(d){
        var vals = d3.keys(d).map(function(key){ return key !== 'Year' ? d[key] : 0 });
        return d3.sum(vals);
      });

      //console.log(maxDateVal);

      // Set domains for axes
      x.domain(d3.extent(wide, function(d) { return d.Year; }));
      y.domain([0, maxDateVal])

      stack.keys(keys);

      stack.order(d3.stackOrderNone);
      stack.offset(d3.stackOffsetNone);

      svg.append('g')
           .attr('class', 'x axis')
           .attr('transform', 'translate(0,' + height + ')')
           .call(xAxis);

      svg.append('g')
           .attr('class', 'y axis')
           .attr('transform', 'translate(' + width + ', 0)')
           .call(yAxis);

      svg.append('g')
          .attr('class', 'y axis left')
          //.attr('transform', 'translate(' + width + ', 0)')
          .call(yAxisLeft);

      svg.append('g')
           .attr('class', 'x gridline')
           .attr('transform', 'translate(0,' + height + ')')
           .call(xGridlines);

      //console.log(wide);
      //console.log(d3.keys(wide[0]));

      var field = d3.keys(wide[0])[1];
      console.log(field);
      //
      var wide_show = wide.map(function(d){
        d_copy = Object.assign({}, d)
        for (i in d3.keys(d_copy)){
          if (d3.keys(d_copy)[i] != "Year" && d3.keys(d_copy)[i] != field){
            d_copy[d3.keys(d_copy)[i]] = 0;
          }
        }
        return d_copy;
      })

      //console.log(wide_show)

      //console.log(wide);

      //console.log(stack(wide));



      var browser = svg.selectAll('.browser')
                        .data(stack(wide))
                          .enter().append('g')
                        .attr('class', function(d){ return 'browser ' + d.key; })
                        //.attr('fill-opacity', 0.9);

      browser.append('path')
             .attr('class', 'area')
             .attr('d', area)
             .style('fill', function(d) { return color(d.key); })
             .attr('id', function(d) { return d.key })
             .classed("layer", true)
             .style('fill-opacity', 0.85)
             // .style('stroke', function(d) { return color(d.key); })
             // .style('stroke-width', 0.1);


      //console.log(stack(wide));

      var stack_wide = stack(wide);
      var stack_long = []
      console.log(stack_wide);

      function longBubbles(wide_data){
        var stack_long = []
        wide_data.forEach(function(row){
          var idx = 0
          console.log(row.key);
          row.forEach(function(entry, idx){
            stack_long.push({
              coord: [entry[0], entry[1]],
              key: row.key,
              index: row.index,
              year: 2013 + idx
            });
            idx++
          })
        })
        return stack_long;
      }


      // stack_wide.forEach(function(row){
      //   var idx = 0
      //   console.log(row.key);
      //   row.forEach(function(entry, idx){
      //     stack_long.push({
      //       coord: [entry[0], entry[1]],
      //       key: row.key,
      //       index: row.index,
      //       year: 2013 + idx
      //     });
      //     idx++
      //   })
      // })
      stack_long = longBubbles(stack_wide);

      console.log(stack_long);
      // add points for each

      svg.selectAll('circle')
            .data(stack_long)
            .enter()
            .append('circle')
            .attr('r', 2)
            .attr('cx', function(d){
              return x(parseDate(d['year']));
            })
            .attr('cy', function(d){
              return y(d['coord'][1]);
            })
            .attr('opacity', 0.6)
            .attr('class', function(d){
              return d['year'];
            })
            .style('fill', 'grey');


    var USER_HEAD = null;

           // Click layer.
     svg.selectAll(".layer").on("click", function(d,i) {
         if (USER_HEAD === null) {
             USER_HEAD = d3.select(this).attr("id");
         } else {
             USER_HEAD = null;
         }

         update();
     });

     function update(){
        var upd_data = [];
        //console.log(USER_HEAD);
        if (USER_HEAD != null){


          var wide_show = wide.map(function(d){
            d_copy = Object.assign({}, d)
            for (i in d3.keys(d_copy)){
              if (d3.keys(d_copy)[i] != "Year" && d3.keys(d_copy)[i] != USER_HEAD){
                d_copy[d3.keys(d_copy)[i]] = 0;
              }
            }
            return d_copy;
          })

          upd_data = stack(wide_show);

          var upd_long = longBubbles(upd_data);
          // updating the domain
          y.domain([0, d3.max(wide_show.map(function(d){
            return d[USER_HEAD];
          }))]);

          d3.selectAll('circle')
            .data(upd_long)
            .transition()
            .duration(1000)
            .attr('cx', function(d){
              return x(parseDate(d['year']));
            })
            .attr('cy', function(d){
              return y(d['coord'][1]);
            })
            .attr('r', 3)
            .style('opacity', function(d){
              return d['key'] != USER_HEAD ? 0 : 1
            })

        }
        else {
          upd_data = stack(wide);
          upd_long = longBubbles(upd_data);
          y.domain([0, maxDateVal])

          d3.selectAll('circle')
            .data(upd_long)
            .transition()
            .duration(1000)
            .attr('cx', function(d){
              return x(parseDate(d['year']));
            })
            .attr('cy', function(d){
              return y(d['coord'][1]);
            })
            .attr('r', 2)
            .style('opacity', '0.6')

        }
        //console.log(upd_data);

        //transition in the area charts


        d3.selectAll(".layer")
          .data(upd_data);

        d3.selectAll(".layer")
          .transition()
          .duration(1000)
          .attr("d", area)
          .style("fill-opacity", function(d){
            return USER_HEAD != null ? 0.5 : 0.85
          })


        svg.select(".y.axis")
          .transition()
          .duration(1000)
          .call(yAxis);

        svg.select(".y.axis.left")
          .transition()
          .duration(1000)
          .call(yAxisLeft);

        console.log(upd_long);
        console.log(d3.selectAll('circle').data());

        // d3.selectAll('circle')
        //   .data(upd_long)
        //   .transition()
        //   .duration(1000)
        //   .attr('cx', function(d){
        //     return x(parseDate(d['year']));
        //   })
        //   .attr('cy', function(d){
        //     return y(d['coord'][1]);
        //   })
        //   .attr('r', 3);

     }

})

  </script>
</body>
